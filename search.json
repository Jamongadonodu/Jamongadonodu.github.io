[{"title":"写一些给自己的话","url":"/2025/08/03/my/","content":"就当是工作日志，时而记些随笔\n25-10-25 Man ！ What can i say \n"},{"title":"Markdown 超级无敌详细教程，草履虫都能学会","url":"/2024/11/15/%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/markdown/","content":"这是一篇古法markdown使用者的传教，没必要深入研究，毕竟文中的很多作者本人也不会（雑魚♥　雑魚♥）），只需掌握基本语法的使用方法即可.\n介绍\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。\n\n观前提示：\n\n我使用的软件是VScode，需要添加一些插件如果你想要轮椅，那就只用这个插件\nOffice Viewer\n\n有了这个插件甚至不需要往下看，不需要学习任何markdown语法，只要你会打字就行\n如果你想要学习一点点（并非一点点）markdown语法，加这几个\n\nMarkdown All in One \nmarkdownlint\nMarkdown Preview Enhanced\n\n\n 经实测，虽然1，3插件许多功能重复，但都加可以做到优势互补，推荐都加\n推荐的学习方法是随用随学，边学边写。 markdown 语法并不难学，根据需要进行学习是比较实用的方法 这篇文章原作者为 Yue_plus，本文是在他的基础上修改补充并完善，还增加了一些好用的html语法（Markdown也支持在其中嵌入HTML）\n下面正式开始标题? 看起来就像上面这个。Markdown 标题有两种格式。\n使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下：我展示的是一级标题=================我展示的是二级标题-----------------\n使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n段落样式Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。\n字体Markdown 可以使用以下几种字体：\n\n斜体文本粗体文本粗斜体文本*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n\n分隔线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n\n我\n\n裂\n\n开\n\n了\n\n***我* * *裂*****开- - -了---\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\nMICROSOFTEDGE.COMGOOGLE.COMBAIDU.COM~~MICROSOFT~~EDGE.COMGO~~O~~GLE.COM~~BAIDU.COM~~\n\n下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：\n\n带下划线文本&lt;u&gt;带下划线文本&lt;/u&gt;\n\n脚注脚注是对文本的补充说明。Markdown 脚注的格式如下:[^要注明的文本]以下实例演示了脚注的用法(通过脚注文内跳转)：\n\nhellowhellow创建脚注格式类似这样 [^hellow][^hellow]: hellow world\n\n锚点锚点用于一篇文章上下段落间跳转:\n\n回到介绍\n\n设置跳转链接 [链接文本](#锚点名称)[回到介绍](#介绍)\n\n这里可以看下锚点和脚注的区别：\n\n锚点用于文档内部的导航，而脚注用于提供额外的信息或引用，且无论你的脚注写在哪永远会显示在文章末尾\nMarkdown 列表Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：\n\n\nfirst\nsecond\nthird* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n有序列表使用数字并加上 . 号来表示，如：\n\n\n第一项\n第二项\n第三项\n\n\n1. 第一项2. 第二项3. 第三项\n列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可：\n\n第一项：\n第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n\n第二项：\n第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n\n\n1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n目录\n目录[TOC][TOC]\n\nMarkdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n\n这是一个区块&gt; 这是一个区块另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：最外层\n\n第一层嵌套\n\n第二层嵌套&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n\n\n\n区块中使用列表区块中使用列表实例如下：\n\n区块中使用列表\n\n第一项\n第二项\n\n\n第一项\n第二项\n第三项&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项\n\n\n\n列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。区块中使用列表实例如下：\n\n第一项\n菜鸟教程学的不仅是技术更是梦想\n\n\n第二项* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项\n\n\nMarkdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：printf() 函数`printf()` 函数\n代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。也可以用 ``` 包裹一段代码（一般使用这个），并指定一种语言（也可以不指定）：实例如下：#include &lt;iostream&gt;int main() &#123;     std::cout &lt;&lt; &quot;Hella, Warld!&quot; &lt;&lt; std::endl;    return 0;&#125;\nMarkdown 链接链接使用方法如下：\n\n链接名称或者直接使用链接地址https://github.com/Yue-plus[链接名称](链接地址)&lt;https://github.com/Yue-plus&gt;\n\n高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行(和脚注类似)：Google\n\n这个链接用 g 作为网址变量 Google\n\n这个链接用 g 作为网址变量 [Google][g]然后在文档的结尾为变量赋值（网址）  [g]: http://www.google.com/\nMarkdown 图片Markdown 图片语法格式如下：![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)开头一个感叹号 !接着一个方括号，里面放上图片的替代文字接着一个英文括号，里面放上图片的网址(也可以使用相对路径)，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。\n\n![Rmer集结](https://rm-static.djicdn.com/tem/3795/b2d8afe5ebc411536923122504681079.jpg &quot;Rmer集结&quot;)\n\n对图片网址使用变量:这个链接用 `rm` 作为网址变量 [Rmer集结][rm].然后在文档的结尾为变量赋值（网址）[rm]: https://rm-static.djicdn.com/tem/3795/b2d8afe5ebc411536923122504681079.jpg\nMarkdown 还没有办法指定图片的高度与宽度，如果需要的话，也可以使用普通的 &lt;img&gt; 标签。\n\n&lt;img src=&quot;https://rm-static.djicdn.com/tem/12037/4fd0873d1538044945299420304.jpg&quot; width=&quot;200px&quot;&gt;\n\n在浏览器中怎么拿到图片链接\n点击图片或拖动图片至标题栏，此时网址处显示的就是图片链接。（这样不保险，有时会链接成图片所在网址）\n\n右键图片，点击为此图像生成QR代码，得到图片二维码和图片链接\n\n\nMarkdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。\n语法格式如下：\n\n\n\n表头\n表头\n\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n\n\n|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。\n\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n\n\nMarkdown EmojiMarkdown中也可以使用Emoji表情，因为emoji使用的是硬编码(Unicode)，所以不用担心emoji能否显示到其他环境中\n将emoji的对应编码两边加上:\n语法格式如下：\n:kissing::nerd_face::alien::clown_face::kissing::nerd_face::alien::clown_face:\n\n但我一般使用这个网址直接复制粘贴(正经人谁手写emoji代码)\n\nemojipedia\n\n再推荐几个有趣的网址\n\nEmoji Combiner\nEmojimix 合成器\nEmoji百宝箱就这个emoji mix我能玩一天\n\nMarkdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如：\n\n使用 Ctrl+Alt+Del 重启电脑使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑\n\n自定义字体的格式\n一起来学习C艹艹吧\n\n\n&lt;font face=&quot;宋体&quot; size=4 color = green&gt;一起来学习C艹艹吧&lt;/font&gt;\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n\n** 正常显示星号 ****文本加粗** \\*\\* 正常显示星号 \\*\\*Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n数学公式当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n可以在行内包含数学公式： $i\\hbar\\frac{\\partial}{\\partial t}\\psi=-\\frac{\\hbar^2}{2m}\\nabla^2\\psi+V\\psi$ 注意单 $ 内部不能有空格！\n\n\n\\begin{align*}\n\\nabla\\cdot\\vec{E} &=& \\frac{\\rho}{\\epsilon_0} \n\\nabla\\cdot\\vec{B} &=& 0\\\\\n\\nabla\\times\\vec{E} &=& -\\frac{\\partial B}{\\partial t} \\\\\n\\nabla\\times\\vec{B} &=& \\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t}\\right)\n\\end{align*}可以在行内包含数学公式： $i\\hbar\\frac&#123;\\partial&#125;&#123;\\partial t&#125;\\psi=-\\frac&#123;\\hbar^2&#125;&#123;2m&#125;\\nabla^2\\psi+V\\psi$ 注意单 `$` 内部不能有空格！$$\\begin&#123;align\\*&#125;\\nabla\\cdot\\vec&#123;E&#125;&amp;=&amp;\\frac&#123;\\rho&#125;&#123;\\epsilon_0&#125;\\\\\\\\\\nabla\\cdot\\vec&#123;B&#125;&amp;=&amp;0\\\\\\\\\\nabla\\times\\vec&#123;E&#125;&amp;=&amp;-\\frac&#123;\\partial B&#125;&#123;\\partial t&#125;\\\\\\\\\\nabla\\times\\vec&#123;B&#125;&amp;=&amp;\\mu_0\\left(\\vec&#123;J&#125;+\\epsilon_0\\frac&#123;\\partial E&#125;&#123;\\partial t&#125;\\right)\\\\\\\\\\end&#123;align\\*&#125;$$\n关于数学公式有哪些可以看这篇文章使用Markdown语法编写数学公式（详细版）\nMermaid流程图考虑到时间和学习成本，本篇不做教学，仅供演示参考，想学习看这个文章,足够了,其实直接使用Xmind插入图片就好了，但图片会增大代码所占用内存,下面的流程图由于浏览器的限制可能无法正常显示\nMermaid 实用教程\n流程图flowchart LR  a(&quot;bsp&quot;)  b(&quot;app&quot;)  a --&gt; b\n    flowchart LR      a(&quot;bsp&quot;)      b(&quot;app&quot;)      a --&gt; b或者    flowchart LR      a(bsp)--&gt;b(app)\n子图表使用以下语法添加子图表flowchart LR    subgraph bsp       subgraph devices          end      subgraph board         end    end\nflowchart LR    subgraph bsp       subgraph devices          end      subgraph board         end    end\n\nhellow. hello world &#8617;\n\n","categories":["教程"],"tags":["Markdown"]},{"title":"电控组代码规范","url":"/2025/08/05/%E7%94%B5%E6%8E%A7/code_format/","content":"遵循良好的变量命名规则和最佳实践对于编写可读、可维护的代码至关重要。合理的变量命名不仅能帮助开发者理解代码的功能，还能在团队合作中减少沟通成本。\n命名规则及代码风格统一遵循linux命名规则和代码风格与标准Linux内核代码有部分区别，如Linux原则上不使用typedef，Linux认为typedef会使可读写变差\n参考文献Linux 内核代码风格1Linux 环境下变量命名规则与最佳实践2Linux下C语言编程风格和规范3\n命名规则\n\n\n\n类型\n规范\n示例\n\n\n\n\n变量\n小写下划线\npresent_value\n\n\n枚举量\n全大写\nKEY_UP\n\n\n常量宏\n全大写\nPWM_MAX\n\n\n结构体类型\n小写下划线+后缀(_t)\ntypedef struct { } motor_data_t\n\n\n枚举类型\n小写下划线+后缀(_e)\ntypedef enum { } motor_mode_e\n\n\n\n\n在定义几个相关的常量时，最好用枚举。\n说明 ：\n\n命名规则\n\n\n变量名应当反映出变量的用途或内容，避免使用无意义的名称。\n禁止出现拼音。请使用简介明了的英文\n减少使用缩写命名，除非像“temp”（temporary）一样非常通用且容易理解\n好的代码是不解自明的：通过变量名即可明白该变量的作用。必要时添加注释辅助说明。\n\n\n同一模块的变量，使用结构体封装管理 如motor_data_t\n特定模块的变量，封装在函数内部，定义为函数内部变量，文件内部变量均标为static\n在项目或代码库中，应保持命名风格的一致性，以便于维护和理解。\n\n函数规则\n函数以名词 + 动词命名,或是模块名 + 动词 + 名词，且以小写下划线的规则书写\n\n\n如‘motor_init’ ‘i2c_read_data’\n\n\n函数应该简短而漂亮，并且只做一件事情，而且把它做好。\n一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理 论上很简单的只有一个很长 (但是简单) 的 case 语句的函数，而且你需要在每个 case 里做很多很小的事情，这样的函数尽管很长，但也是可以的。\n函数的另外一个衡量标准是本地变量的数量。此数量不应超过 5－10 个，否则你的函数就有问题了。\n文件内部调用的函数均标为static，外部调用的函数在头文件中声明\n\n代码风格代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。\n但介于每个人都有自己的代码风格，这个部分不会硬性要求统一，但还是推荐使用以下代码风格\n缩进制表符是 8 个字符，所以缩进也是 8 个字符。理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的 屏幕连续看了 20 小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。\n把长的行和字符串打散每一行的长度的限制是 80 列，我们强烈建议您遵守这个惯例。\n括号“{”和“}”的使用原则1) 对于结构体、if/for/while/switch语句, “{”不另起一行,例如:struct var_data &#123;    int len;    char data[0];&#125;; if (a == b) &#123;    a = c;    d = a;&#125; for (i = 0; i &lt; 10; i++) &#123;    a = c;    d = a;&#125;\n2) if和else混用的情况下, else语句不另起一行,例如:if (x == y)&#123;    ...&#125; else if (x &gt; y) &#123;    ...&#125; else &#123;    ...&#125;\n3) 对于函数, “{”另起一行,例如:int add (int a, int b)&#123;    return a + b;&#125;\n空格的使用1) 关键字后加空格在这些关键字后面加空格：\n\nif, switch, case, for, do, while\n\n但是这些不加：\n\nsizeof, typeof, alignof, attribute例如:for (i = 0; i &lt; 10; i++)     a = c;if （x &gt; y）s=sizeof(int)\n\n2) 括号内，紧挨着括号不加空格\n3) 对于指针，”*“号挨着名字而不是类型\n4) 操作符两侧加空格以下二元或三元操作符两侧要加空格：\n\n= + - &lt; &gt; * / % | &amp; ^ &lt;= &gt;= == != ? :\n\n但是以下一元操作符，不加空格：\n\n&amp; * + - ~ ! sizeof typeof alignof attribute defined\n\n自增自减符号。不加空格：\n\n++ —\n\n结构体成员操作符，不加空格：\n\n‘.’ 和 “-&gt;”\n\n不要在行尾加空格。\n注释Linux风格的注释是c89 “/… /”风格。长 (多行) 注释的首选风格是：/* * This is the preferred style for multi-line * comments in the Linux kernel source code. * Please use it consistently. * * Description:  A column of asterisks on the left side, * with beginning and ending almost-blank lines. */原则：\n\n注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的： 更好的做法是让别人一看你的代码就可以明白，解释写的很差的代码是浪费时间。\n\n一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把 注释放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，那么你的函数不符合函数规则\n\n你应该做的，是把注释放在函数的头部，告诉人们它做了什么， 也可以加上它做这些事情的原因。\n\n\n需要统一的部分宏函数宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。一般的，如果能写成内联函数就不要写成像函数的宏。含有多个语句的宏应该被包含在一个 do-while{0} 代码块里：#define macrofun(a, b, c)                       \\        do &#123;                                    \\                if (a == 5)                     \\                        do_this(b, c);          \\        &#125; while (0)\n内联（并不常用，没有把握就不用）有一个常见的误解是 内联 是 gcc 提供的可以让代码运行更快的一个选项。虽然使 用内联函数有时候是恰当的 (比如作为一种替代宏的方式，请看第十二章)，不过很多情 况下不是这样。inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。\n一个基本的原则：内联函数通常不超过三行\n条件编译只要可能，就不要在 .c 文件里面使用预处理条件 (#if, #ifdef)；这样做让代码更难 阅读并且更难去跟踪逻辑。\n最好倾向于编译整个函数，而不是函数的一部分或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理 条件到这个辅助函数内。\n封装\n1. Linux 内核代码风格 &#8617;\n\n\n2. Linux 环境下变量命名规则与最佳实践 &#8617;\n\n\n3. Linux下C语言编程风格和规范 &#8617;\n\n","categories":["电控"],"tags":["导论"]},{"title":"CubeMX配置详解","url":"/2025/07/23/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32HAL/CubeMX%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/","content":"\n异步模式（Asynchronous）特点\n\n\n无需时钟线（仅需TX/RX）\n通过波特率（Baud Rate）同步数据传输\n\n应用\n\n最常见的串口通信（如调试打印、传感器数据读取）\n\n\n同步模式（Synchronous）特点\n\n\n需时钟线（CK引脚）同步数据\n支持更高的传输速率，但硬件更复杂\n\n应用\n\n高速数据传输（如SPI替代方案）\n\n\n单线半双工模式（Single Wire, Half-Duplex）特点\n\n\n单根数据线（TX和RX复用）\n同一时间只能发送或接收\n\n应用\n\n节省引脚资源（如单总线传感器）\n\n\n多处理器通信（Multiprocessor Communication）特点\n\n\n通过地址字节实现多设备通信\n主设备可唤醒特定从设备\n\n应用\n\n多节点控制（如工业RS-485网络）\n\n\nIrDA模式特点\n\n\n支持红外通信协议（需外接IrDA收发器）\n数据需调制为脉冲信号\n\n应用\n\n红外遥控、短距离无线传输\n\n\nLIN模式特点\n\n\n支持LIN总线协议（局部互联网络）\n适用于汽车电子\n单线传输，低成本\n\n应用\n\n车门控制、座椅调节等车载设备\n\n\n智能卡模式（SmartCard）特点\n\n\n符合ISO 7816标准\n支持SIM卡或金融卡通信\n需提供时钟信号（可选带卡时钟模式）\n\n应用\n\nPOS机、智能卡读卡器\n\n","categories":["STM32"],"tags":["CubeMX"]},{"title":"stm32HAL库学习笔记合集","url":"/2024/12/05/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32HAL/stm32HALStudy/","content":"STM32 HAL库基础知识学习笔记，参考了b站大佬的HAL库教程，感谢铁头山羊和keysking\n以stm32f103c8t6为例，基于铁头山羊stm32 HAL库入门教程\nkeysking的STM32教程\nGPIO篇认识引脚\nIO复用与重映射IO复用 ： 同一个IO引脚具备多个不同的功能复用功能重映射 ： 将冲突的复用功能移动到备用引脚上\nGPIOGPIO : General Purpose Input/Output,通用目的的输入/输出\nGPIO的8种工作模式\nGPIO的输出模式\n推挽 ：一对MOS管交替导通，对外输出低电压或高电压开漏 ：PMOS保持关闭，对外输出低电压或高阻态\n通用 ：直接控制引脚高低电平复用 ：其他模块托管（如UART等）\nGPIO的输出速度低速 ：2MHz中速 ：10～25MHz高速 ：50～100MHz\n以stm32f103c8t6为例：\nGPIO的输入模式引脚浮空 ：会接受空间电磁波，随机读取0或1上拉电阻 ：当引脚浮空时，提供默认的高电压下拉电阻 ：当引脚浮空时，提供默认的低电压模拟输入 ：接受模拟信号，应用于ADC\nUART篇UART基础知识Tx与Rx\n串口的数据帧\n奇校验 ：1的总数为奇数。偶校验 ：1的总数为偶数。\n波特率 ：每秒传输位的数量波特率越高，传输速率越快，但收发双方应当遵循相同的波特率，常用的为9600,115200\n两种不同的串口\nUART/USART 工作模式\nI2C篇I2C总线基础知识\n\nI2C接上拉电阻是为了实现逻辑线与\n\nI2C实现过程起始位\n寻址\n出现NAK代表寻址失败，一般有几种原因\n\n地址错误\n从机正忙\n从机故障\n\n数据传输\n停止位\nI2C通讯速率\n在快速模式下可以设置时钟信号的占空比，一般有TL/TH=2/1（常用）和16/9\n时钟系统篇一台电脑和单片机类比\n电路分为组合逻辑电路和时序逻辑电路组合逻辑电路 ：不含记忆元件时序逻辑电路 ：含有记忆元件 有时钟信号才能工作\n单片机外设全是时序逻辑电路因此单片机需要给每一个模块提供时钟信号\n时钟树以stm32f103c8t6为例\n\n内部时钟与外部时钟\n\n除此之外，还有锁相环（PLL），其本质为倍频器\n\n时钟源与外设\n\nCubeMX时钟配置\nSPI篇SPI基础知识SPI总线 ：Serial Peripheral Interface,串行外设接口适用于高速，双向数据传输场景\n\nSPI引脚MOSI ：主机发送从机接收MISO ：主机接收从机发送SCK  ：串行时钟线NSS ：低电平有效从机选择\n\nSPI的重要参数\n波特率 ：波特率选取原则选择从机允许的最大值，考虑设备和电路承受的极限\n\n比特位传输顺序MSB ：高位有效LSB ：低位有效\n\n数据位长度8-bit16-bit\n\n时钟极性 CPOL(Clock Polarity)\n\n时钟相位 CPHA(Clock Phase)\n\n\n由此得到SPI的四种时钟模式\n选取原则：始终优先遵循从设备(如传感器、存储器等)数据手册中指定的SPI模式要求常见选择如下\n\nFlash存储器(如W25Q系列)：通常模式0或模式3\nSD卡(SPI模式)：模式0\nADXL345加速度计：模式3\nnRF24L01无线模块：模式0\n\n中断篇中断优先级中断嵌套NVIC中断仲裁器定时器篇定时器内部框图\n大致分为4部分\n时基单元从模式控制器输入捕获输出比较","categories":["STM32"],"tags":["study"]},{"title":"一篇关于单片机程序设计模式的思考","url":"/2025/02/24/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%9E%B6%E6%9E%84/ProgrammingModeofMCU/","content":"基于初学freeRTOS，对单片机裸机的程序设计模式有了进一步的理解，在此分享给大家，希望能够帮到你\n单片机程序设计模式裸机程序设计模式以“做饭”和“接电话”为例\n\n轮询//轮询void mian()&#123;    Init();     //初始化    while(1)    &#123;      cook();   //做饭      phone();  //接电话    &#125;&#125;\n分析\n在while循环里依次调用2个功能模块，这两个模块相互之间有影响：如果“煮饭”太花时间，就会导致迟迟无法“接电话”\n\n使用轮询模式编写程序看起来很简单，但是要求 while 循环里调用到的模块要执行得非常快(避免相互影响)\n\n由于不同模块往往执行速度不同，在复杂场景里反而增加了编程难度，因此轮询模式局限于模块较少且模块执行速度非常快的小项目\n\n\n\n前后台—-按需分配基于中断流程和主函数流程配合\n//前后台void mian()&#123;    Init();     //初始化    while(1)    &#123;      cook();   //做饭      //后台,执行速度较慢且一直在执行    &#125;&#125;void interrupt()&#123;    phone();  //接电话    //前台,执行速度较快&#125;\nwhile循环里的代码是后台程序，平时都是while循环在运行；\n分析\n前后台模式是按照模块实现所需时间进行按需分配\n\n在该过程中，“接电话”响应非常迅速，在“做饭”过程中会暂停下来去“接电话”,而由于“接电话”执行速度较快，就无法影响(或影响很小)“做饭”\n\n当模块增多，多个中断会增加暂停时间，就会导致 “做饭”迟迟无法执行，这在对时序有较高精准度的情况下(如传感器定时采集数据)不适用\n\n场景复杂的情况下，函数之间的相互影响依旧存在，并且各函数间的时序不够精准，因此普通的前后台模式局限于中小型对时序没有太大要求的项目\n\n\n\n裸机开发的程序设计模式常用就这两种，但都有局限，需要改进\n前后台改进改进1：基于定时器驱动的前后台这里有两种改进方法，思路都是将不同的功能模块分配相应的时间片周期，代码实现时对应标志位\n一.普通的定时器驱动// 前后台程序: 定时器驱动void main()&#123;    while (1)    &#123;        // 后台程序    &#125;&#125;// 前台程序: 固定时间触发一次中断void timer_interrupt()&#123;    static int cnt = 0;    cnt++;    if (cnt % 5 == 0)    &#123;        cook();   //做饭用了5个中断时间    &#125;    else if (cnt % 2 == 0)    &#123;        phone();  //接电话用了2个中断时间    &#125;&#125;\n这种模式适合调用周期性的函数，并且每一个函数执行的时间不能超过一个定时器周期。但遇到某个函数很耗时，这种场景下程序遭遇到了轮询模式的缺点：函数相互之间有影响。\n二.执行规定时间的功能模块先来看看HAL库的一个函数\n\nHAL_Delay();\n\nHAL_GetTick();为获取当前时间戳\n__weak void HAL_Delay(uint32_t Delay)&#123;  uint32_t tickstart = HAL_GetTick();   //获取当前时间戳作为开始时间  uint32_t wait = Delay;                //等待时间  /* 添加 freq(频率) 以保证最短等待时间 */  if (wait &lt; HAL_MAX_DELAY)  &#123;    wait += (uint32_t)(uwTickFreq);     //uwTickFreq为系统时钟频率(1kHz),所对应时间为1ms  &#125;                                     //这也是为什么HAL_Delay函数中的参数单位为ms  while ((HAL_GetTick() - tickstart) &lt; wait)  &#123;  &#125;                                     //延时&#125;\n由上述函数启发，可编写执行规定时间的函数\nvoid HAL_FuncDelay(void *(FuncBegin)(void), void *(FuncEnd)(void), uint32_t Delay)&#123;  uint32_t tickstart = HAL_GetTick();  uint32_t wait = Delay;  /* Add a freq to guarantee minimum wait */  if (wait &lt; HAL_MAX_DELAY)  &#123;    wait += (uint32_t)(uwTickFreq);  &#125;  while ((HAL_GetTick() - tickstart) &lt; wait)  &#123;    FuncBegin();  &#125;  FuncEnd();&#125;\n虽然这样可以控制函数执行时间，但属于阻塞式编程，在对实时性有要求的场景还是不太合适，所以并不推荐这么写，但要会使用这个函数HAL_GetTick()\n改进2：基于状态机(state)或标志位(Flag)的前后台主函数轮询，将功能函数根据完成状态拆分为多个状态或立多个标志位标识状态\n标志位和状态机原理相似，以下仅以状态机为例\n/* 做饭 */void cook(int state)&#123;    state = 0；    switch (state)    &#123;        case 0:        &#123;            /* 准备米和水 */            /* 进入下一个状态 */            state++;            break;        &#125;        case 1:        &#123;            /* 淘米 */            /* 进入下一个状态 */            state++;            break;        &#125;        case 2:        &#123;            /* 使用电饭煲 */            /* 进入下一个状态 */            state++;            break;        &#125;        case 3:        &#123;            /* 等待米饭 */            /* 恢复到初始状态 */            state = 0;            break;        &#125;    &#125;&#125;/*接电话*/void phone(int state)&#123;    state = 0;    switch (state)    &#123;        case 0:        &#123;            /* 拿起手机 */            /* 进入下一个状态 */            state++;            break;        &#125;        case 1:        &#123;            /* 接听 */            /* 进入下一个状态 */            state++;            break;        &#125;        case 2:        &#123;            /* 对话 */            /* 恢复到初始状态 */            state = 0;            break;        &#125;    &#125;&#125;\n这样的好处是可以减少函数间的相互影响，但当程序内容复杂时，函数间的相互影响不可避免，且每个函数都要写多个状态，不利于我们封装和移植\n进阶面对上述情况的缺点，实际上最好的方法是加上实时操作系统(RTOS),让函数交替进行\n但在裸机不加操作系统的情况下，可以用到以下模式\n中断+标志位+状态机的前后台（推荐）主函数可以这样写\nvoid main()&#123;  while(1)  &#123;    if(flag_cook)    &#123;      cook();//再将每个功能函数拆分为多个状态，过程如上省略      Flag_cook=0;    &#125;    if(flag_phone)    phone();    Flag_phone=0;  &#125;&#125;\n/*定时器或事件中断，以定时器中断为例*/void timer_interrupt(void)&#123;  static int cnt = 0;    cnt++;    if (cnt % 5 == 0) //该标志位对应的函数所用时间    &#123;        Flag_cook=1;    &#125;    else if (cnt % 2 == 0)    &#123;        Flag_phone=1;    &#125;&#125;\n这种模式适用于大多数场景，且综合了以上各模式的优点，缺点是有许多冗杂代码，可以用更高效的数据结构(结构体，结构体指针，结构体数组,函数指针等)优化\n优化假设我们有N个功能函数(任务)要处理void main()&#123;  init();  while(1)  &#123;    TaskScheduler();  &#125;&#125;\n在任务处理函数中优化数据结构,其中i可以代表某个任务void TaskHandle(void)&#123;  static uint8_t i;  for(i=0; i&lt;TASK_NUM_MAX; i++)  &#123;    if(Task[i].Flag)    &#123;      Task[i].Flag=0;      Task[i].pTaskFunc();    &#125;   &#125;&#125;\n定时器中断作为任务调度器void TaskScheduler(void) &#123;    for (int i = 0; i &lt;TASK_NUM_MAX ; i++) &#123;        if (Task[i].Flag == 0 &amp;&amp; Task[i].timcnt &gt; 0) &#123;            Task[i].timcnt--;  // 计时减1            if (Task[i].timcnt == 0) &#123;                Task[i].pTaskFunc();  // 执行任务函数                Task[i].Flag = 1;         // 标记任务已完成            &#125;        &#125;    &#125;&#125;\n其实思路和第一种没多大区别，优化主要在于数据结构，删去了很多冗余代码，下面的才是重点\n#define TASK_NUM_MAX Ntypedef struct &#123;  uint_8 Flag;  uint16_t timcnt;  void (*pTaskFunc)(void);&#125;TaskStruct;static TaskStruct Task[]=&#123;  &#123;0,2,cook&#125;;  &#123;0,5,phone&#125;;  &#123;...&#125;&#125;\n这种写法效仿RTOS，思路模式属于裸机的极限了，但还能优化数据结构 ，比如使用链表再进一步优化，但都用到链表了，不如使用freeRTOS\n想要更高的性能就要用到RTOS(实时操作系统)常见的RTOS有freeRTOS，ThreadX，LiteOS等，我们常用的是freeRTOS\n","categories":["嵌入式"],"tags":["架构"]}]